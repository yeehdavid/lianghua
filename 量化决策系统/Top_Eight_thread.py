from PyQt5 import QtCore
import tushare as ts
import xgboost as xgb
import time
import datetime

class Top_Eight_thread(QtCore.QThread):
    def __init__(self, parent=None):
        super(Top_Eight_thread, self).__init__(parent)

    _signal_ = QtCore.pyqtSignal(dict)#定义一个传递字典信息的信号

    def run(self):

        today = start = datetime.date.today()  # 获得今天的日期
        temp = 7
        while temp:
            start = start - datetime.timedelta(days=1)  # 用今天日期减掉时间差，参数为1天，获得昨天的日期
            temp = temp - 1

        model = xgb.Booster()
        model.load_model('softprob.model')#加载训练好的Xgboost模型
        top = {}
        l = ['600578', '601258', '600008', '000415', '300070', '000402', '600009', '000826', '000778', '600376',
             '600196', '000538', '601016', '600795', '600398', '000709', '600157', '600011', '600739', '600221',
             '002236', '002202', '600309', '000423', '600519', '600600', '000568', '000503', '000413', '002195',
             '000729', '000858', '000963', '000333', '002304', '601866', '600705', '600518', '002399', '600783',
             '600276', '002230', '601898', '601718', '601633', '000651', '600886', '600863', '600660', '000725',
             '002424', '002739', '600998', '002241', '601098', '600188', '600027', '000883', '600703', '600115',
             '600674', '002415', '000069', '000895', '000046', '002422', '000540', '600867', '600373', '601179',
             '002450', '601933', '002470', '600100', '600256', '600089', '000623', '601607', '600208', '600585',
             '600582', '600317', '002153', '000917', '601958', '601669', '600816', '601628', '600649', '000156',
             '601991', '600362', '600111', '000898', '300124', '300251', '600037', '000625', '600827', '600021',
             '600570', '600085', '601899', '601988', '600871', '603885', '600606', '002294', '300058', '600332',
             '601088', '300059', '002456', '600959', '600737', '601018', '000999', '600900', '300024', '600415',
             '300104', '000876', '601888', '000768', '300085', '002252', '600446', '600066', '002024', '002568',
             '002027', '600074', '600118', '600804', '601992', '601928', '601919', '601727', '601600', '601288',
             '601216', '601118', '601021', '600583', '600547', '600485', '600406', '600340', '600252', '600050',
             '600023', '600022', '300315', '002385', '002146', '002129', '000559', '000166', '000157', '000001',
             '002736', '600177', '601186', '601808', '600068', '300015', '600873', '600019', '000750', '600642',
             '600588', '002007', '000776', '300168', '002500', '600704', '601618', '600170', '300027', '600060',
             '600029', '600690', '300017', '600061', '601985', '002008', '000060', '600031', '600895', '601318',
             '600637', '000630', '601555', '600352', '601328', '601117', '000793', '600109', '601211', '002183',
             '002152', '000002', '601377', '601169', '600741', '600688', '000728', '600016', '601601', '600648',
             '600030', '601857', '601818', '600535', '601166', '000063', '601111', '002292', '601872', '000686',
             '601788', '601336', '000039', '002081', '600010', '601225', '600150', '300002', '002065', '600104',
             '600999', '600875', '601939', '600028', '600036', '600837', '601688', '000783', '600839', '300146',
             '300003', '001979', '000425', '600685', '600372', '000738', '300133', '600383', '000338', '600489',
             '603993', '600048', '000977', '601398', '601099', '600958', '600000', '600663', '600666', '600820',
             '601333', '601106', '601998', '300144', '601800', '000009', '600153', '600369', '601009', '000712',
             '601198', '002594', '601006', '600887', '000100', '603000', '002673', '601390', '601901', '000800',
             '601608', '000825', '002465', '601766', '600271', '002475', '600018', '600015', '601989', '002142',
             '000792', '600893', '000061', '600718', '000027', '000839', '600038', '601668', '600098']
        i = 0  #i用于更新进度条信息
        for code in l:

            self._signal_.emit({'value':i})
            #print(code)
            i += 1

            code = str(code)
            df = ts.get_hist_data(code, start=str(start), end=str(today))
            #print(start,today - datetime.timedelta(days=1))
            df = df.head(3)

            d1 = df[0:1]
            d2 = df[1:2]
            d3 = df[2:3]


            if df.index.size != 3:
                continue

            #                    ))
            l = []
            l.append(float(d1['close'] / d1['open']))
            l.append(float(d1['close'] / d1['high']))
            l.append(float(d1['close'] / d1['low']))
            l.append(float(d1['close'] / d1['ma5']))
            l.append(float(d1['close'] / d1['ma10']))
            l.append(float(d1['close'] / d1['ma20']))
            l.append(float(d1['p_change']))
            l.append(float(d1['volume'] / d1['v_ma5']))
            l.append(float(d1['volume'] / d1['v_ma10']))
            l.append(float(d1['volume'] / d1['v_ma20']))

            l.append(float(d2['close'] / d2['open']))
            l.append(float(d2['close'] / d2['high']))
            l.append(float(d2['close'] / d2['low']))
            l.append(float(d2['close'] / d2['ma5']))
            l.append(float(d2['close'] / d2['ma10']))
            l.append(float(d2['close'] / d2['ma20']))
            l.append(float(d2['p_change']))
            l.append(float(d2['volume'] / d2['v_ma5']))
            l.append(float(d2['volume'] / d2['v_ma10']))
            l.append(float(d2['volume'] / d2['v_ma20']))

            l.append(float(d3['close'] / d3['open']))
            l.append(float(d3['close'] / d3['high']))
            l.append(float(d3['close'] / d3['low']))
            l.append(float(d3['close'] / d3['ma5']))
            l.append(float(d3['close'] / d3['ma10']))
            l.append(float(d3['close'] / d3['ma20']))
            l.append(float(d3['p_change']))
            l.append(float(d3['volume'] / d3['v_ma5']))
            l.append(float(d3['volume'] / d3['v_ma10']))
            l.append(float(d3['volume'] / d3['v_ma20']))
            test = xgb.DMatrix(l)

            pre = model.predict(test)
            if len(top) < 8:
                top[code] = float(pre[0][1])

            else:
                min_ = min(zip(top.values(), top.keys()))
                if min_[0] < float(pre[0][1]):
                    top.pop(min_[1])
                    top[code] = float(pre[0][1])


        #keys = keys.append(300)
        self._signal_.emit(top)
        time.sleep(2)